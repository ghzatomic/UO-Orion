const algoritimo_caminho = 'balanced'
const gridSize = 8;


function auto_pvm() {
  var lastX = 0
  var lastZ = 0
  var lastY = 0
  var runAll = true
  Shared.AddVar('RMCancelRun', false);
  while (runAll) {
    TargetNextEnemy_PvM()
    Orion.Wait(500)
    var enemy = Orion.FindObject('lasttarget');
    lastX = enemy.X()
    lastY = enemy.Y()
    lastZ = enemy.Z()
    Orion.CharPrint(self, 906, 'Mudando ' + enemy.Name());
    Orion.Wait(500)
    while (!enemy.Dead()) {
      if (Orion.FindObject('lasttarget') == null) {
        enemy = Orion.FindObject('lasttarget');
        Orion.Wait(100)
        Orion.CharPrint(self, 906, 'Morreu ! ');
        break
      }
      if (!enemy) {
        Orion.CharPrint(self, 906, 'Nao Enemy ');
        break
      }
      if (Shared.GetVar('RMCancelRun')) {
        Orion.CharPrint(self, 906, 'RMCancelRun ');
        runAll = false
        break
      }

      if (Shared.GetVar('AUTOPVM_FUNCTION')) {
        eval(Shared.GetVar('AUTOPVM_FUNCTION'))(enemy)
      } else {
        if (Player.X() != enemy.X() && Player.Y() != enemy.Y()) {
          var distancia = 1
          Orion.WalkTo(enemy.X(), enemy.Y(), Player.Z(), distancia, Player.Z(), 1, 1);
        }
      }

      if (enemy.Dead()) {
        Orion.CharPrint(self, 906, 'Morreu ! ');
        break
      }

    }
    if (Shared.GetVar('AUTOPVM_DEAD_FUNCTION')) {
      eval(Shared.GetVar('AUTOPVM_DEAD_FUNCTION'))(enemy, lastX, lastY, lastZ)
    }
  }


}

function mapeiaTela() {
  function callback(i, j) {
    //console.log(`Célula em (${i}, ${j})`);
  }
  percorrerAteLimite(10, 10, 2, 2, 8, 8, callback);

}


function writeFileLine(data) {
  var loc = 'E:/git/UO Orion Macros/teste.txt'
  var file = Orion.NewFile(loc);
  var create = file.Open(loc)
  if (create) {
    file.WriteLine(data);
    file.Close();
  }
}

function create2DArray(x, y, initialValue) {
  var array = [];
  for (var i = 0; i < x; i++) {
    var row = [];
    for (var j = 0; j < y; j++) {
      row.push(initialValue);
    }
    array.push(row);
  }
  return array;
}

function percorrerAteLimite(x, y, startX, startY, maxX, maxY, callback) {
  var directions = [
    [1, 0], // direita
    [-1, 0], // esquerda
    [0, 1], // abaixo
    [0, -1], // acima
    [1, 1], // diagonal direita abaixo
    [-1, -1], // diagonal esquerda acima
    [1, -1], // diagonal direita acima
    [-1, 1] // diagonal esquerda abaixo
  ];
  var dl = directions.length
  var visitados = [];
  for (var i = 0; i < x; i++) {
    visitados.push([]);
    for (var j = 0; j < y; j++) {
      visitados[i][j] = false;
    }
  }
  var queue = [[startX, startY]];
  var readIndex = 0; // Índice para leitura da fila

  while (readIndex < queue.length) {
    var current = queue[readIndex++];
    var curX = current[0];
    var curY = current[1];

    if (curX < 0 || curX >= x || curY < 0 || curY >= y || visitados[curX][curY] || curX >= maxX || curY >= maxY) {
      continue;
    }

    visitados[curX][curY] = true;
    callback(curX, curY);

    for (var i = 0; i < directions.length; i++) {
      var newX = curX + directions[i][0];
      var newY = curY + directions[i][1];
      queue.push([newX, newY]);
    }
  }
}




function andarPara(x, y) {
  var isWalking = Orion.IsWalking()
  if (isWalking) {
    Orion.StopWalking()
    Orion.ClearBadLocations();
  }
  Orion.WalkTo(x, y, Player.Z(), 1, Player.Z() + 20, 1, 1);
}

function isOutsideRegion(x, y, x0, y0, r) {
  // Calcula o quadrado da distância euclidiana entre o ponto (x, y) e o ponto central (x0, y0)
  const deltaX = x - x0;
  const deltaY = y - y0;
  const distanceSquared = deltaX * deltaX + deltaY * deltaY;
  // Calcula o quadrado do raio
  const rSquared = r * r;
  // Retorna true se o quadrado da distância for maior que o quadrado do raio
  return distanceSquared > rSquared;
}

function canWalk(x, y) {
  //var lista = Orion.GetPathArrayEx(x,y,256,1,255,2,2)

}

function get_object_at(list, x, y) {
  if (list) {
    for (var i = 0; i < list.length; i++) {
      var obj = list[i];
      if (obj && obj.X() && obj.Y()) {
        if (obj.X() == x && obj.Y() == y) {
          return obj
        }
      }

    }
  }

}

function runManager() {
  while (true) {
    const listSafeSpot = Shared.GetVar('RMListSafeSpot');
    if (listSafeSpot) {

    }
  }
}

function sqrt(value) {
  if (value < 0) return NaN;
  var x = value;
  var y = 1;
  const e = 0.000001; // margem de erro

  while (x - y > e) {
    x = (x + y) / 2;
    y = value / x;
  }

  return x;
}

function estaProximo(x1, y1, x2, y2, distanciaMaxima) {
  const deltaX = x2 - x1;
  const deltaY = y2 - y1;
  const distancia = sqrt(deltaX * deltaX + deltaY * deltaY);
  return distancia <= distanciaMaxima;
}

function autoSeguirInimigoProx(callbackProximo) {
  var isWalking = Orion.IsWalking()
  Shared.AddVar('RMCancelRun', true);
  if (isWalking) {
    Orion.StopWalking()
    Orion.ClearBadLocations();
  }
  var enemy = Orion.FindObject('lasttarget');
  //walkToTarget(enemy)
  if (enemy) {
    const distanciaMaxima = 2;
    const proximidade = estaProximo(Player.X(), Player.Y(), enemy.X(), enemy.Y(), distanciaMaxima);
    if (proximidade) {
      callbackProximo()
    }
    Orion.WalkTo(enemy.X(), enemy.Y(), enemy.Z(), 1, enemy.Z() + 5, 1, 1);
    Orion.Attack(enemy);
  }
}

function autoSeguirInimigo() {
  var funcProximidade = function () {
    ArmarArma();
  }

  autoSeguirInimigoProx(funcProximidade)

}


function walkToTarget(target) {
  Shared.AddVar('RMCancelRun', true);
  if (!target) {
    return false;
  }
  var x = target.X();
  var y = target.Y();
  var z = target.Z();
  var pathArray = Orion.GetPathArray(x, y, z);
  while (pathArray.length > 0) {
    Orion.ClearBadLocations();
    var npcList = Orion.FindType('any', 'any', 'ground', 'ignoreself', '5');
    for (i = 0; i < npcList.length; i++) {
      var npc = Orion.FindObject(npcList[i]);
      Orion.SetBadLocation(npc.X(), npc.Y());
    }
    var stepTarget = pathArray[0];
    var check = Orion.WalkTo(stepTarget.X(), stepTarget.Y(), stepTarget.Z(), 1, 255, 1, 1);
    if (!check) {
      Orion.Print('Não da para ir !');
      return false;
    }
    x = target.X();
    y = target.Y();
    z = target.Z();
    pathArray = Orion.GetPathArray(x, y, z);
  }
  return true;
}


function stopRun() {
  Shared.AddVar('RMCancelRun', true);
}

function correr2() {
  correrLocal(gridSize, undefined)
}

function correrLocal(gridSizeLocal, qtdePassos) {
  Shared.AddVar('RMCancelRun', true);
  var onFindSpot = function (mapeado, mapa, playerX, playerY) {
    Shared.AddVar('RMCancelRun', false);
    const listSafeSpot = findPathToSafeSpot(mapeado, playerX, playerY, algoritimo_caminho, gridSizeLocal)
    if (listSafeSpot && listSafeSpot.length > 0) {
      for (var i = 0; i < listSafeSpot.length; i++) {
        Orion.CharPrint(self, 906, 'Teste ' + " " + i);
        if (qtdePassos) {
          if (qtdePassos > i) {
            Orion.CharPrint(self, 906, 'Correndo ' + qtdePassos + " " + i);
            break
          }
        }
        if (i % 0) {
          continue
        }

        const cancelRun = Shared.GetVar('RMCancelRun');
        if (cancelRun) {
          Shared.AddVar('RMCancelRun', false);
          break
        }
        const safeSpot = listSafeSpot[i]
        if (safeSpot) {
          var xRun = mapa[safeSpot.y][safeSpot.x][0]
          var yRun = mapa[safeSpot.y][safeSpot.x][1]
          //Orion.CharPrint(self, 906, "aa "+xRun+" - "+yRun);
          var callb = function (x, y) {
            andarPara(x, y)
            //Orion.CharPrint(self, 906, "aaccc "+x+" - "+y);
          }
          //drawPath(mapeado, playerPosition.x, playerPosition.y, safeSpot.x, safeSpot.y, callb);
          callb(xRun, yRun)
        }
      }
    }
  }

  correrFunc(onFindSpot, gridSizeLocal)

}

function correr() {

  var onFindSpot = function (mapeado, mapa, playerX, playerY) {

    const listSafeSpot = findPathToSafeSpot(mapeado, playerX, playerY, algoritimo_caminho)
    if (listSafeSpot && listSafeSpot.length > 0) {
      const safeSpot = listSafeSpot[listSafeSpot.length - 1]//findSafeSpot(mapeado, playerX, playerY)
      if (safeSpot) {
        var xRun = mapa[safeSpot.y][safeSpot.x][0]
        var yRun = mapa[safeSpot.y][safeSpot.x][1]
        //Orion.CharPrint(self, 906, "aa "+xRun+" - "+yRun);
        var callb = function (x, y) {
          andarPara(x, y)
          //Orion.CharPrint(self, 906, "aaccc "+x+" - "+y);
        }
        //drawPath(mapeado, playerPosition.x, playerPosition.y, safeSpot.x, safeSpot.y, callb);
        callb(xRun, yRun)
      }
    }
  }

  correrFunc(onFindSpot)

}

function correrFunc(onFindSpot, gridSizeLocal) {
  var print = true
  var target = Orion.FindObject('lasttarget');
  //if (target){
  enemyList = Orion.FindTypeEx("any", "-1", "ground", "ignorefriends|ignoreself|live", gridSizeLocal ? gridSizeLocal : gridSize, "gray|red")//Orion.FindType("any", "-1", "ground", "near|mobile|ignorefriends", 18, "gray|red");
  //var simInimigoX = target.X()
  //var simInimigoY = target.Y()
  var inimigoList = []//[[simInimigoX,simInimigoY]]
  for (var i = 0; i < enemyList.length; i++) {
    var inim = enemyList[i];
    inimigoList.push([inim.X(), inim.Y()])
  }
  var inimigoListPosition = []
  var vazio = "."
  var impassavel = "A"
  var inimigo = "E"
  var eu = "T"
  var onComplete = function (mapa, gradeX, gradeY) {
    var playerPosition = undefined
    var loc = 'D:/git/UO Orion Macros/teste.txt'
    var file = print ? Orion.NewFile(loc) : undefined
    var create = print ? file.Open(loc) : true
    if (create) {
      var mapeado = []
      for (var i = 0; i < gradeX; i++) {
        var mapeadoRow = []
        var row = "";
        for (var j = 0; j < gradeY; j++) {
          var strObj = vazio
          if (mapa[i][j][0] == Player.X() && mapa[i][j][1] == Player.Y()) {
            strObj = eu
            playerPosition = { x: i, y: j }
          } else {
            var achouInimigo = false
            for (var inimIndex = 0; inimIndex < inimigoList.length; inimIndex++) {
              var inimigoX = inimigoList[inimIndex][0]
              var inimigoY = inimigoList[inimIndex][1]
              if (mapa[i][j][0] == inimigoX && mapa[i][j][1] == inimigoY) {
                achouInimigo = true
                strObj = inimigo
                inimigoListPosition[inimigoListPosition.length] = { x: i, y: j }
                break
              }
            }
            if (!achouInimigo) {
              var andavel = isTileAndavel(mapa[i][j][0], mapa[i][j][1], Player.Z())
              if (!andavel) {
                strObj = impassavel
              }
            }
          }
          mapeadoRow[j] = strObj
          row += '' + strObj;
        }
        mapeado[i] = mapeadoRow
        if (print) {
          file.Write(row + "\n");
        }
      }
      if (playerPosition) {
        onFindSpot(mapeado, mapa, playerPosition.x, playerPosition.y);
      }
      if (print) {
        file.Close();
      }
    }

  }
  //row += '('+mapa[i][j][0]+','+mapa[i][j][1]+'-'+andavel+'),';
  scanTela(onComplete);
  //}
}
function testexx() {
  //var objetos_chao = Orion.FindTypeEx('any', '-1', ground, 'ignoreself', '18');
  //var inimigos = Orion.FindType('any', '-1', ground, 'ignoreself', '18');
  //Orion.CanWalk("North", 4093,321,Player.Z())
  //var obj = get_object_at(objetos_chao,4093,321)
  //var obj2 = get_object_at(objetos_chao,4094,323)
  //Orion.GetLandTiledata(graph)
  //tileAt = Orion.GetTiles('any', 4091, 323, 0, 10);
  //Orion.WalkTo(4091, 323, 0, 0, 10, 2, 1);
  //Orion.CharPrint(self, 906, ""+data);
  //var data = Orion.GetLandTiledata(Orion.GetTiles('any', 4093, 322, 0, 3)[0].Graphic())
  //var fl = data.Flags()
  //Orion.CharPrint(self, 906, ""+fl);
  var onComplete = function (mapa, gradeX, gradeY) {

    var loc = 'E:/git/UO Orion Macros/teste.txt'
    var file = Orion.NewFile(loc);
    var create = file.Open(loc)
    if (create) {
      for (var i = 0; i < gradeX; i++) {
        var row = "";
        for (var j = 0; j < gradeY; j++) {
          //Orion.CanWalk("North", mapa[i][j][0]-1,mapa[i][j][1],Player.Z())
          var andavel = isTileAndavel(mapa[i][j][0], mapa[i][j][1], Player.Z())
          row += '(' + mapa[i][j][0] + ',' + mapa[i][j][1] + '-' + andavel + '),';
        }
        file.WriteLine(row);
      }
      file.Close();
    }
  }
  scanTela(onComplete, gridSizeLocal);

}

function scanTela(onComplete, gridSizeLocal) {
  //var tiles = Orion.GetTiles("any",Player.X,Player.Y);
  //if (tiles){
  //  Orion.CharPrint(self, 906, "aaaa"+Orion.GetGraphic(tiles));
  //}
  //Orion.CharPrint(self, 906, "CanWalk -"+Player.X()+","+Player.Y()+" - "+Orion.CanWalk("North", Player.X()-1,Player.Y()-1,Player.Z()));
  var StartX = gridSizeLocal ? gridSizeLocal : gridSize / 2
  var StartY = gridSizeLocal ? gridSizeLocal : gridSize / 2
  var gradeX = gridSizeLocal ? gridSizeLocal : gridSize
  var gradeY = gridSizeLocal ? gridSizeLocal : gridSize
  var run = create2DArray(gradeX, gradeY, 0);
  var count = 1
  var callback = function (x, y) {
    var xPlayer = Player.X()
    var yPlayer = Player.Y()
    xPlayer = xPlayer + (x - StartX)
    yPlayer = yPlayer + (y - StartY)
    run[y][x] = [xPlayer, yPlayer] // Inverte o xy para se adequar ao jogo

    if (count >= gradeX * gradeY) {
      onComplete(run, gradeX, gradeY)
    }

    count = count + 1
  }

  percorrerAteLimite(gradeX, gradeY, StartX, StartY, gradeX, gradeY, callback)

}



function swap(str, i, j) {
  const temp = str.charAt(i);
  str = setCharAt(str, i, str.charAt(j));
  str = setCharAt(str, j, temp);
  return str;
}

function setCharAt(str, index, chr) {
  if (index > str.length - 1) return str;
  return str.substring(0, index) + chr + str.substring(index + 1);
}

function createGrid(gridString, gridSizeLocal) {
  const grid = [];
  for (var i = 0; i < gridSizeLocal ? gridSizeLocal : gridSize; i++) {
    grid.push(gridString.slice(i * gridSizeLocal ? gridSizeLocal : gridSize, (i + 1) * gridSizeLocal ? gridSizeLocal : gridSize).split(''));
  }
  return grid;
}

function abs(value) {
  return value < 0 ? -value : value;
}

function distance(x1, y1, x2, y2) {
  return abs(x2 - x1) + abs(y2 - y1);
}

function hasLineOfSight(grid, x1, y1, x2, y2) {
  const dx = abs(x2 - x1);
  const dy = abs(y2 - y1);
  const sx = (x1 < x2) ? 1 : -1;
  const sy = (y1 < y2) ? 1 : -1;
  var err = dx - dy;

  while (true) {
    if (x1 === x2 && y1 === y2) return true;
    if (grid[y1][x1] === 'A') return false;

    const e2 = err * 2;
    if (e2 > -dy) {
      err -= dy;
      x1 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y1 += sy;
    }

    if (x1 === x2 && y1 === y2) break;
  }
  return true;
}

function calculateRisk(grid, x, y) {
  var risk = 0;
  const directions = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 },
    { dx: 1, dy: 1 },
    { dx: -1, dy: -1 },
    { dx: 1, dy: -1 },
    { dx: -1, dy: 1 }
  ];
  for (var i = 0; i < directions.length; i++) {
    const nx = x + directions[i].dx;
    const ny = y + directions[i].dy;
    if (nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length) {
      if (grid[ny][nx] === 'E') {
        if (hasLineOfSight(grid, nx, ny, x, y)) {
          risk += 10; // Penalidade extra para estar na linha de visão
        } else {
          risk += 1;
        }
      }
    }
  }
  return risk;
}

function findSafeSpot(grid, playerX, playerY, strategy, gridSizeLocal) {
  var bestSpot = null;
  var optimalScore = (strategy === 'shortest') ? Infinity : -Infinity;

  for (var y = 0; y < grid.length; y++) {
    for (var x = 0; x < grid[0].length; x++) {
      if (grid[y][x] === '.' || grid[y][x] === 'A') {
        var safe = true;
        var totalRisk = 0;
        for (var ey = 0; ey < grid.length; ey++) {
          for (var ex = 0; ex < grid[0].length; ex++) {
            if (grid[ey][ex] === 'E') {
              if (hasLineOfSight(grid, ex, ey, x, y)) {
                safe = false;
                break;
              }
              totalRisk += calculateRisk(grid, ex, ey);
            }
          }
          if (!safe) break;
        }
        const distanceToPlayer = distance(playerX, playerY, x, y);
        var score;
        if (strategy === 'shortest') {
          score = distanceToPlayer + totalRisk * 5;
          if (score < optimalScore && distanceToPlayer > 2) {
            bestSpot = { x: x, y: y };
            optimalScore = score;
          }
        } else if (strategy === 'farthest') {
          score = distanceToPlayer - totalRisk * 3;
          if (score > optimalScore) {
            bestSpot = { x: x, y: y };
            optimalScore = score;
          }
        } else if (strategy === 'balanced') {
          score = distanceToPlayer - totalRisk * 1;
          if (score > optimalScore) {
            bestSpot = { x: x, y: y };
            optimalScore = score;
          }
        }
      }
    }
  }

  // Se nenhum local seguro for encontrado, vá para o canto mais distante
  if (!bestSpot) {
    bestSpot = { x: gridSizeLocal ? gridSizeLocal : gridSize - 1, y: gridSizeLocal ? gridSizeLocal : gridSize - 1 };
    for (var y = 0; y < grid.length; y++) {
      for (var x = 0; x < grid[0].length; x++) {
        if (grid[y][x] === '.' || grid[y][x] === 'A') {
          const dist = distance(playerX, playerY, x, y);
          if (dist > distance(playerX, playerY, bestSpot.x, bestSpot.y)) {
            bestSpot = { x: x, y: y };
          }
        }
      }
    }
  }

  return bestSpot;
}

function minimax(grid, depth, isMaximizingPlayer, alpha, beta, playerX, playerY) {
  if (depth === 0) {
    return calculateRisk(grid, playerX, playerY);
  }

  const directions = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 },
    { dx: 1, dy: 1 },
    { dx: -1, dy: -1 },
    { dx: 1, dy: -1 },
    { dx: -1, dy: 1 }
  ];

  if (isMaximizingPlayer) {
    var maxEval = -Infinity;
    for (var i = 0; i < directions.length; i++) {
      const nx = playerX + directions[i].dx;
      const ny = playerY + directions[i].dy;
      if (nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length && grid[ny][nx] === '.') {
        const eval = minimax(grid, depth - 1, false, alpha, beta, nx, ny);
        maxEval = Math.max(maxEval, eval);
        alpha = Math.max(alpha, eval);
        if (beta <= alpha) {
          break;
        }
      }
    }
    return maxEval;
  } else {
    var minEval = Infinity;
    for (var i = 0; i < directions.length; i++) {
      const nx = playerX + directions[i].dx;
      const ny = playerY + directions[i].dy;
      if (nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length && grid[ny][nx] === '.') {
        const eval = minimax(grid, depth - 1, true, alpha, beta, nx, ny);
        minEval = Math.min(minEval, eval);
        beta = Math.min(beta, eval);
        if (beta <= alpha) {
          break;
        }
      }
    }
    return minEval;
  }
}

function findBestMove(grid, playerX, playerY, strategy) {
  var bestMove = null;
  var bestValue = -Infinity;
  const directions = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 },
    { dx: 1, dy: 1 },
    { dx: -1, dy: -1 },
    { dx: 1, dy: -1 },
    { dx: -1, dy: 1 }
  ];

  for (var i = 0; i < directions.length; i++) {
    const nx = playerX + directions[i].dx;
    const ny = playerY + directions[i].dy;
    if (nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length && grid[ny][nx] === '.') {
      const moveValue = minimax(grid, 3, false, -Infinity, Infinity, nx, ny);
      if (moveValue > bestValue) {
        bestMove = { x: nx, y: ny };
        bestValue = moveValue;
      }
    }
  }
  return bestMove;
}

function aStarPath(grid, startX, startY, endX, endY) {
  const openSet = [{ x: startX, y: startY, f: 0, g: 0, h: distance(startX, startY, endX, endY), parent: null }];
  const closedSet = [];
  const visited = [];
  for (var i = 0; i < grid.length; i++) {
    const row = [];
    for (var j = 0; j < grid[i].length; j++) {
      row.push(false);
    }
    visited.push(row);
  }

  while (openSet.length > 0) {
    var lowestFIndex = 0;
    for (var i = 1; i < openSet.length; i++) {
      if (openSet[i].f < openSet[lowestFIndex].f) {
        lowestFIndex = i;
      }
    }
    const current = openSet[lowestFIndex];

    if (current.x === endX && current.y === endY) {
      const path = [];
      var temp = current;
      while (temp) {
        path.push({ x: temp.x, y: temp.y });
        temp = temp.parent;
      }
      return path.reverse();
    }

    openSet.splice(lowestFIndex, 1);
    closedSet.push(current);
    visited[current.y][current.x] = true;

    const directions = [
      { dx: 1, dy: 0 },
      { dx: -1, dy: 0 },
      { dx: 0, dy: 1 },
      { dx: 0, dy: -1 },
      { dx: 1, dy: 1 },
      { dx: -1, dy: -1 },
      { dx: 1, dy: -1 },
      { dx: -1, dy: 1 }
    ];

    for (var i = 0; i < directions.length; i++) {
      const nx = current.x + directions[i].dx;
      const ny = current.y + directions[i].dy;
      if (nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length && !visited[ny][nx] && (grid[ny][nx] === '.' || grid[ny][nx] === 'T')) {
        const g = current.g + 1;
        const h = distance(nx, ny, endX, endY);
        const risk = calculateRisk(grid, nx, ny);
        const f = g + h + risk;
        const neighbor = { x: nx, y: ny, f: f, g: g, h: h, parent: current };

        var existing = false;
        for (var j = 0; j < openSet.length; j++) {
          if (openSet[j].x === nx && openSet[j].y === ny) {
            existing = true;
            if (g < openSet[j].g) {
              openSet[j] = neighbor;
            }
            break;
          }
        }
        if (!existing) {
          openSet.push(neighbor);
        }
      }
    }
  }

  return [];
}

function findPathToSafeSpot(grid, playerX, playerY, strategy, gridSizeLocal) {
  var safeSpot = findSafeSpot(grid, playerX, playerY, strategy, gridSizeLocal);
  if (safeSpot) {
    if (safeSpot.length < 5) {
      safeSpot = findSafeSpot(grid, playerX, playerY, 'shortest', gridSizeLocal);
    }
    if (safeSpot) {
      const path = aStarPath(grid, playerX, playerY, safeSpot.x, safeSpot.y);
      if (path.length > 0) {
        return path;
      }
    }
  }
  // Se nenhum local seguro for encontrado ou se o A* não encontrou um caminho, use BFS para encontrar uma saída possível
  return bfsPath(grid, playerX, playerY);
}

function bfsPath(grid, startX, startY, gridSizeLocal) {
  const queue = [{ x: startX, y: startY, path: [] }];
  const visited = [];
  for (var i = 0; i < grid.length; i++) {
    const row = [];
    for (var j = 0; j < grid[i].length; j++) {
      row.push(false);
    }
    visited.push(row);
  }
  visited[startY][startX] = true;

  const directions = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 },
    { dx: 1, dy: 1 },
    { dx: -1, dy: -1 },
    { dx: 1, dy: -1 },
    { dx: -1, dy: 1 }
  ];

  while (queue.length > 0) {
    const current = queue.shift();
    const x = current.x;
    const y = current.y;
    const path = current.path;

    for (var i = 0; i < directions.length; i++) {
      const nx = x + directions[i].dx;
      const ny = y + directions[i].dy;

      if (nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length && !visited[ny][nx] && grid[ny][nx] === '.') {
        const newPath = path.concat({ x: nx, y: ny });
        if ((nx === 0 || nx === gridSizeLocal ? gridSizeLocal : gridSize - 1 || ny === 0 || ny === gridSizeLocal ? gridSizeLocal : gridSize - 1)) {
          return newPath;
        }
        visited[ny][nx] = true;
        queue.push({ x: nx, y: ny, path: newPath });
      }
    }
  }

  return [];
}

// ------------------------------------------- NOVO SISTEMA ----------------------------------
function CharPos() {
  var player = Player;
  return {
    X: player.X(),
    Y: player.Y()
  };
}
var tileMap = {};

function generateTileMap(radius) {
  var playerPos = CharPos();
  for (var x = playerPos.X - radius; x <= playerPos.X + radius; x++) {
    for (var y = playerPos.Y - radius; y <= playerPos.Y + radius; y++) {
      var key = x + ',' + y;
      tileMap[key] = isTileAndavel(x, y, playerPos.Z);
    }
  }
}

function isTilePassable(x, y) {
  return isTileAndavel(x, y) // Ignorando Z
}
function isTilePassableCached(x, y) {
  return isTileAndavelCached(x, y) // Ignorando Z
}

function isTileAndavelCached(x, y) {
  var key = x + ',' + y;
  return tileMap[key] !== undefined ? tileMap[key] : false;
}

var losCache = {}; // Cache para linha de visão de inimigos

// Função para verificar se há inimigos na linha de visão
function enemiesInLOS(x, y, enemies, useCache) {
  var cacheKey = x + ',' + y;
  if (useCache && losCache[cacheKey] !== undefined) {
    return losCache[cacheKey];
  }

  for (var i = 0; i < enemies.length; i++) {
    if (isPathClear(x, y, enemies[i].X(), enemies[i].Y(), true)) {
      losCache[cacheKey] = true;
      return true;
    }
  }
  losCache[cacheKey] = false;
  return false;
}


function findPositionBehindObject(object, enemies) {
  var directions = [
    { dx: 1, dy: 0 },   // Direita
    { dx: -1, dy: 0 },  // Esquerda
    { dx: 0, dy: 1 },   // Baixo
    { dx: 0, dy: -1 },  // Cima
    { dx: 1, dy: 1 },   // Diagonal Baixo-Direita
    { dx: 1, dy: -1 },  // Diagonal Cima-Direita
    { dx: -1, dy: 1 },  // Diagonal Baixo-Esquerda
    { dx: -1, dy: -1 }  // Diagonal Cima-Esquerda
  ];

  var playerPos = CharPos();
  var bestPosition = null;
  var minDistance = Infinity;

  for (var i = 0; i < directions.length; i++) {
    var newX = object.X + directions[i].dx;
    var newY = object.Y + directions[i].dy;
    var newZ = object.Z;

    if (!enemiesInLOS(newX, newY, enemies,true) && getTileStatus(newX, newY, playerPos, null, enemies) === '.') {
      var distance = (playerPos.X - newX) * (playerPos.X - newX) + (playerPos.Y - newY) * (playerPos.Y - newY);
      if (distance < minDistance) {
        minDistance = distance;
        bestPosition = { X: newX, Y: newY, Z: newZ };
      }
    }
  }

  return bestPosition;
}

function findNearestHideout(enemies) {
  var playerPos = CharPos();
  var nearestHideout = null;
  var minDistance = Infinity;

  // Use o cache de tiles gerado anteriormente
  for (var key in tileMap) {
    var coords = key.split(',');
    var x = parseInt(coords[0]);
    var y = parseInt(coords[1]);

    if (tileMap[key] && !enemiesInLOS(x, y, enemies, true)) {
      var object = { X: x, Y: y, Z: playerPos.Z };
      var hideoutPosition = findPositionBehindObject(object, enemies);

      if (hideoutPosition && !enemiesInLOS(hideoutPosition.X, hideoutPosition.Y, enemies, true)) {
        var distance = (playerPos.X - hideoutPosition.X) * (playerPos.X - hideoutPosition.X) + 
                       (playerPos.Y - hideoutPosition.Y) * (playerPos.Y - hideoutPosition.Y);
        if (distance < minDistance) {
          minDistance = distance;
          nearestHideout = hideoutPosition;
        }
      }
    }
  }

  return nearestHideout;
}

// Função para determinar o status de um tile
function getTileStatus(x, y, playerPos, hideoutPos, enemies) {
  if (playerPos.X == x && playerPos.Y == y) {
    return 'P'; // Posição do jogador
  } else if (hideoutPos && hideoutPos.X == x && hideoutPos.Y == y) {
    return 'H'; // Posição do esconderijo
  }

  // Verifica se há um jogador inimigo no tile
  for (var i = 0; i < enemies.length; i++) {
    if (enemies[i].X() == x && enemies[i].Y() == y) {
      return 'E'; // Jogador inimigo
    }
  }

  if (isTileAndavelCached(x, y)) {
    return '.'; // Tile passável
  } else {
    return 'T'; // Tile bloqueado
  }
}

// Função principal para executar a lógica
function runEsconderSe() {
  flag = "mobile";
  var mainTarget = Orion.ClientLastAttack();
  if (mainTarget != undefined) {
    var mainEnemy = Orion.FindObject(mainTarget);
    if (mainEnemy && mainEnemy.Exists()) {
      if (mainEnemy.IsHuman()) {
        flag = "human";
      }
    }
  }
  pathCache = {}
  losCache = {}; // Cache para linha de visão de inimigos

  generateTileMap(gridSize); // Gera o mapa de tiles andáveis
  Orion.Print("Tiles Mapeadas")
  var enemies = Orion.FindTypeEx("-1", "-1", "ground", flag + "|ignoreself", gridSize, "any");
  Orion.Print("Inimigos : "+enemies.length)
  var fileName = 'D:/git/UO Orion Macros/map.txt';
  var hideout = findNearestHideout(enemies);
  var areaMap = scanArea(gridSize, hideout ? { X: hideout.X, Y: hideout.Y } : null, enemies);
  saveMapToFile(areaMap, fileName);
  if (hideout) {
    Orion.Print(null, "Esconderijo encontrado em " + hideout.X + ", " + hideout.Y + ", " + hideout.Z);
    moveToHideout(hideout);
  } else {
    Orion.Print(null, "Nenhum esconderijo seguro encontrado.");
  }
  pathCache = {}
  losCache = {};
}

var pathCache = {};

function isPathClear(x1, y1, x2, y2, cached) {
  var cacheKey = x1 + ',' + y1 + '-' + x2 + ',' + y2;
  if (pathCache[cacheKey] !== undefined) {
    return pathCache[cacheKey];
  }

  var dx = Math.abs(x2 - x1);
  var dy = Math.abs(y2 - y1);
  var sx = (x1 < x2) ? 1 : -1;
  var sy = (y1 < y2) ? 1 : -1;
  var err = dx - dy;
  var maxIterations = dx + dy; // Número máximo de iterações para evitar loop infinito
  var iterations = 0;

  while (iterations <= maxIterations) {
    iterations++;
    if (cached) {
      if (!isTileAndavelCached(x1, y1)) {
        pathCache[cacheKey] = false;
        return false;
      }
    } else {
      if (!isTilePassable(x1, y1)) {
        pathCache[cacheKey] = false;
        return false;
      }
    }
    if (x1 === x2 && y1 === y2) {
      break;
    }
    var e2 = 2 * err;
    if (e2 > -dy) {
      err -= dy;
      x1 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y1 += sy;
    }
  }

  pathCache[cacheKey] = true;
  return true;
}

function isTileAndavel(x, y, z) {
  var containsObj = false
  var objContains = undefined
  var objList = Orion.FindType('any', 'any', 'ground', 'ignoreself', 'xyz: ' + x + ',' + y + ',' + z);
  
  for (i = 0; i < objList.length; i++) {
    var o = Orion.FindObject(objList[i]);
    if (o.X() == x && o.Y() == y && o.Z() <= z && !o.IsMulti()) {
      containsObj = true
      objContains = o
    }
  }

  //var arr = Orion.GetPathArray(x,y,z);
  //Orion.Wait(1000)
  var pathOk = true//arr.length <= 0
  /*if (isOutsideRegion(x, y, Player.X(), Player.Y(), 1)){
    //Implementar o CanWalk
    pathOk = true
  }*/
  var tilesAt = Orion.GetTiles('any', x, y, z, 255)
  var tileAndavel = true
  if (tilesAt) {
    /*if (tilesAt.length == 0){
      tileAndavel = false //Verificar na caverna e nas dungeons
    }*/
    for (var i = 0; i < tilesAt.length; i++) {
      var data = tilesAt[i]
      var strFlag = data.Flags().toString(16)
      if (strFlag[strFlag.length - 2] + strFlag[strFlag.length - 1] === "40" || strFlag[strFlag.length - 2] + strFlag[strFlag.length - 1] === "50") {
        tileAndavel = false
        break
      } else {
        var strFlag = Orion.GetLandTiledata(data.Graphic()).Flags().toString(16)
        if (strFlag[strFlag.length - 2] + strFlag[strFlag.length - 1] === "40") {
          tileAndavel = false
          break
        }
      }
    }

  } else {
    return !containsObj // N tem tile eh pq nao existe nada
  }
  if (tileAndavel) {
    var testaTileNegra = Orion.GetTiles('land', x, y)
    if (testaTileNegra && testaTileNegra.length > 0) {
      if (Orion.GetTiles('land', x, y)[0].Flags().toString() == '80') {
        tileAndavel = false
      } else {
        /*if (Player.Z()<0 && Orion.GetTiles('land', x, y)[0].Z()>Player.Z()){
          tileAndavel = false // Caso da parte preta da cave
        }*/
      }
    }
  }
  //Orion.CharPrint(self, 906, 'eee '+pathOk+","+tileAndavel+","+containsObj);
  return tileAndavel && !containsObj
}

// Função para mover o jogador para o esconderijo
function moveToHideout(hideout) {
  if (hideout) {
    Orion.StopWalking();
    Orion.WalkTo(hideout.X, hideout.Y, Player.Z(), 0, hideout.Z, 1, 1);
    Orion.Print(null, "Movendo para o esconderijo em " + hideout.X + ", " + hideout.Y + ", " + hideout.Z);
  } else {
    Orion.Print(null, "Nenhum esconderijo seguro encontrado.");
  }
}


// Função para varrer uma área ao redor do jogador
function scanArea(radius, hideoutPos, enemies) {
  var playerPos = CharPos();
  var areaMap = [];
  var i, j;

  for (i = -radius; i <= radius; i++) {
    var row = [];
    for (j = -radius; j <= radius; j++) {
      var x = playerPos.X + i;
      var y = playerPos.Y + j;
      var status = getTileStatus(x, y, playerPos, hideoutPos, enemies);
      row.push(status);
    }
    areaMap.push(row);
  }

  return areaMap;
}

// Função para salvar o mapa em um arquivo de texto
function saveMapToFile(areaMap, fileName) {
  var file = Orion.NewFile(fileName);
  var create = file.Open(fileName);
  if (create) {
    var i, j;
    for (i = 0; i < areaMap.length; i++) {
      var row = '';
      for (j = 0; j < areaMap[i].length; j++) {
        row += areaMap[i][j];
      }
      file.Write(row + "\n");
    }
    file.Close();
  }
}


function findPositionBehindObject_old(object, enemies) {
  var directions = [
    { dx: 1, dy: 0 },   // Direita
    { dx: -1, dy: 0 },  // Esquerda
    { dx: 0, dy: 1 },   // Baixo
    { dx: 0, dy: -1 },  // Cima
    { dx: 1, dy: 1 },   // Diagonal Baixo-Direita
    { dx: 1, dy: -1 },  // Diagonal Cima-Direita
    { dx: -1, dy: 1 },  // Diagonal Baixo-Esquerda
    { dx: -1, dy: -1 }  // Diagonal Cima-Esquerda
  ];

  var playerPos = CharPos();
  var bestPosition = null;
  var minDistance = Infinity;

  for (var i = 0; i < directions.length; i++) {
    var newX = object.X + directions[i].dx;
    var newY = object.Y + directions[i].dy;
    var newZ = object.Z;
    if (isTileAndavel(newX, newY, newZ) && !enemiesInLOS(newX, newY, enemies)) {
      var distance = (playerPos.X - newX) * (playerPos.X - newX) + (playerPos.Y - newY) * (playerPos.Y - newY);
      //var distance = Orion.GetDistance(newX, newY);
      if (distance < minDistance) {
        minDistance = distance;
        bestPosition = { X: newX, Y: newY, Z: newZ };
      }
    }
  }
  return bestPosition;
}

// Função para encontrar o esconderijo mais próximo
function findNearestHideout_old(enemies) {
  // Procurando por objetos que podem servir como esconderijo
  var potentialHideouts = Orion.FindTypeEx("any", "any", "ground", "static|item", gridSize, "any");
  var playerPos = CharPos();
  var nearestHideout = null;
  var minDistance = Infinity;

  for (var i = 0; i < potentialHideouts.length; i++) {
    var hideout = potentialHideouts[i];
    var positionBehind = findPositionBehindObject({ X: hideout.X(), Y: hideout.Y(), Z: hideout.Z() }, enemies);
    if (positionBehind) {
      var distance = (playerPos.X - newX) * (playerPos.X - newX) + (playerPos.Y - newY) * (playerPos.Y - newY);
      //var distance = Orion.GetDistance(positionBehind.X, positionBehind.Y);
      if (distance < minDistance) {
        nearestHideout = positionBehind;
        minDistance = distance;
      }
    }
  }

  return nearestHideout;
}

// ------------------------------- Manter Distancia -------------------------------
function isEnemyWithinDistance(enemies, distance) {
  var playerPos = CharPos();
  for (var i = 0; i < enemies.length; i++) {
    var enemy = enemies[i];
    var dist = Orion.GetDistance(enemy.X(), enemy.Y());
    if (dist <= distance) {
      return true;
    }
  }
  return false;
}

function moveToSafeDistanceFromEnemies(mainEnemy, otherEnemies, safeDistance, closeDistance) {
  var playerPos = CharPos();
  var bestPosition = null;
  var bestDistance = -9999;

  for (var dx = -safeDistance; dx <= safeDistance; dx++) {
    for (var dy = -safeDistance; dy <= safeDistance; dy++) {
      var newX = playerPos.X + dx;
      var newY = playerPos.Y + dy;
      if (isTilePassable(newX, newY)) {
        var minDistanceToEnemies = Infinity;
        var allEnemiesFarEnough = true;

        // Distância do inimigo principal
        var mainEnemyDistance = Orion.GetDistance(newX, newY);
        if (mainEnemyDistance < closeDistance || mainEnemyDistance > safeDistance || !isPathClear(newX, newY, mainEnemy.X(), mainEnemy.Y())) {
          continue;
        }

        for (var j = 0; j < otherEnemies.length; j++) {
          var enemy = otherEnemies[j];
          var distance = Orion.GetDistance(newX, newY);
          if (distance < closeDistance || distance > safeDistance) {
            allEnemiesFarEnough = false;
            break;
          }
          if (distance < minDistanceToEnemies) {
            minDistanceToEnemies = distance;
          }
        }

        if (allEnemiesFarEnough && mainEnemyDistance <= safeDistance && minDistanceToEnemies > bestDistance) {
          bestDistance = minDistanceToEnemies;
          bestPosition = { X: newX, Y: newY };
        }
      }
    }
  }

  if (bestPosition) {
    Orion.StopWalking();
    Orion.WalkTo(bestPosition.X, bestPosition.Y, Player.Z(), 1, Player.Z(), 1, 1, 3000);
    Orion.Wait(4000);
    Orion.Print(null, "Movendo para posição segura em " + bestPosition.X + ", " + bestPosition.Y);
  } else {
    Orion.Print(null, "Nenhuma posição segura encontrada.");
  }
}

function materDistanciaComVisao() {
  Orion.Print(null,"Aqui")
  materDistanciaComVisao(Orion.ClientLastAttack(), true)
}

function materDistanciaComVisao(mainTarget, print) {
  if (print == undefined) {
    print = true;
  }
  var flag = "mobile"
  if (mainTarget == undefined) {
    mainTarget = Orion.ClientLastAttack();
    if (mainTarget == undefined) {
      mainTarget = "any";
    }
  }
  var mainEnemy = Orion.FindObject(mainTarget);
  if (!mainEnemy || !mainEnemy.Exists()) {
    if (print) {
      Orion.Print(null, "Inimigo principal não encontrado.");
    }
  }else{
    if (mainEnemy.IsHuman){
      flag = "human"
    }
  }

  var safeDistance = 7;
  var closeDistance = 4;
  var otherEnemies = Orion.FindTypeEx("any", "any", "ground", "mobile|ignoreself", safeDistance, "any");

  if (isEnemyWithinDistance(mainEnemy ? [mainEnemy].concat(otherEnemies) : otherEnemies, closeDistance)) {
    if (print) {
      Orion.Print(null, "Inimigo a 5 tiles de distância, mantendo distância segura.");
    }
    moveToSafeDistanceFromEnemies(mainEnemy, otherEnemies, safeDistance);
  } else {
    if (print) {
      Orion.Print(null, "Nenhum inimigo próximo.");
    }
  }
}


function autoPVMBowFunction(enemy) {
  if (!isPathClear(Player.X(), Player.Y(), enemy.X(), enemy.Y())) {
    var distancia = 0
    Orion.WalkTo(enemy.X(), enemy.Y(), Player.Z(), distancia, enemy.Z(), 1, 1, 2000);
  }
  materDistanciaComVisao(Orion.ClientLastAttack(), false);
}

function autoPVMDeadFunction(enemy, x, y, z) {
  Orion.CharPrint(self, 906, "Buscando dinheiro")
  Orion.WalkTo(x, y, z, 1, z, 1, 1, 3000);
}

function flexadaPVM() {
  Orion.Exec('auto_pvm')
  Shared.AddVar('AUTOPVM_FUNCTION', "autoPVMBowFunction");
  Shared.AddVar('AUTOPVM_DEAD_FUNCTION', "autoPVMDeadFunction");
  var target = Orion.FindObject(Orion.ClientLastAttack());
  if (target) {
    while (!target.Dead()) {
      if (!Shared.GetVar('CPIsCasting')) {
        ArmarBow();
        Orion.Wait(100)
        materDistanciaComVisao(target.Serial(), false);
        Orion.Attack(target)
        for (var index = 0; index < 100; index++) {
          if (!Shared.GetVar('RMCancelRun')) {
            return
          }
          Orion.Wait(10)
          if (!Shared.GetVar('RMCancelRun')) {
            return
          }
          materDistanciaComVisao(target.Serial(), false);
        }
        target = Orion.FindObject(Orion.ClientLastAttack());
        Orion.Wait(100)
        if (!Shared.GetVar('RMCancelRun')) {
          return
        }
      }

    }
  }
}

function testeCall() {
  var find = Orion.FindTypeEx("any", "any", "ground", "mobile|ignoreself", 7, "any")
  for (var index = 0; index < find.length; index++) {
    const element = find[index];
    Orion.Print("Nome: " + element.Name())
  }
}

function testeLOS() {

}