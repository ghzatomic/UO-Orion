
const gridSize = 30;

function mapeiaTela(){
  function callback(i, j) {
    //console.log(`Célula em (${i}, ${j})`);
  }
  percorrerAteLimite(10, 10, 2, 2, 8, 8, callback);

}


function writeFileLine(data){
  var loc = 'E:/git/UO Orion Macros/teste.txt'
  var file = Orion.NewFile(loc);
  var create = file.Open(loc)
  if (create){
    file.WriteLine(data);
    file.Close();
  }
}

function create2DArray(x, y, initialValue) {
    var array = [];
    for (var i = 0; i < x; i++) {
        var row = [];
        for (var j = 0; j < y; j++) {
            row.push(initialValue);
        }
        array.push(row);
    }
    return array;
}

function percorrerAteLimite(x, y, startX, startY, maxX, maxY, callback) {
  var directions = [
    [1, 0], // direita
    [-1, 0], // esquerda
    [0, 1], // abaixo
    [0, -1], // acima
    [1, 1], // diagonal direita abaixo
    [-1, -1], // diagonal esquerda acima
    [1, -1], // diagonal direita acima
    [-1, 1] // diagonal esquerda abaixo
  ];
  var dl = directions.length
  var visitados = [];
  for (var i = 0; i < x; i++) {
      visitados.push([]);
      for (var j = 0; j < y; j++) {
          visitados[i][j] = false;
      }
  }
  var queue = [[startX, startY]];
  var readIndex = 0; // Índice para leitura da fila
    
  while (readIndex < queue.length) {
        var current = queue[readIndex++];
        var curX = current[0];
        var curY = current[1];
        
        if (curX < 0 || curX >= x || curY < 0 || curY >= y || visitados[curX][curY] || curX >= maxX || curY >= maxY) {
            continue;
        }

        visitados[curX][curY] = true;
        callback(curX, curY);
        
        for (var i = 0; i < directions.length; i++) {
            var newX = curX + directions[i][0];
            var newY = curY + directions[i][1];
            queue.push([newX, newY]);
        }
    }
}




function andarPara(x,y){
  var isWalking = Orion.IsWalking()
  if (isWalking) {
      Orion.StopWalking()
      Orion.ClearBadLocations();
  }
  Orion.WalkTo(x, y, Player.Z(), 1, Player.Z()+20, 1, 1);
}

function isOutsideRegion(x, y, x0, y0, r) {
  // Calcula o quadrado da distância euclidiana entre o ponto (x, y) e o ponto central (x0, y0)
  const deltaX = x - x0;
  const deltaY = y - y0;
  const distanceSquared = deltaX * deltaX + deltaY * deltaY;
  // Calcula o quadrado do raio
  const rSquared = r * r;
  // Retorna true se o quadrado da distância for maior que o quadrado do raio
  return distanceSquared > rSquared;
}

function isTileAndavel(x,y,z){
  Orion.ClearBadLocations();
  var objList = Orion.FindType('any', 'any', 'ground', 'ignoreself', 'xyz: '+x+','+y+','+z);
  var containsObj = false
  var objContains = undefined
  for(i=0; i < objList.length; i++){
      var o = Orion.FindObject(objList[i]);
      if (o.X() == x && o.Y() == y && o.Z() <= z && !o.IsMulti()){
        containsObj = true
        objContains = o
      }
      //Orion.SetBadLocation(o.X(), o.Y());
  }
  
  //var arr = Orion.GetPathArray(x,y,z);
  //Orion.Wait(1000)
  var pathOk = true//arr.length <= 0
  /*if (isOutsideRegion(x, y, Player.X(), Player.Y(), 1)){
    //Implementar o CanWalk
    pathOk = true
  }*/
  var tilesAt = Orion.GetTiles('any', x, y,z,255)
  var tileAndavel = true
  if (tilesAt){
    /*if (tilesAt.length == 0){
      tileAndavel = false //Verificar na caverna e nas dungeons
    }*/
    for (var i = 0; i < tilesAt.length; i++) {
      var data = tilesAt[i]
      var strFlag = data.Flags().toString(16)
      if (strFlag[strFlag.length-2]+strFlag[strFlag.length-1] === "40" || strFlag[strFlag.length-2]+strFlag[strFlag.length-1] === "50"){
        tileAndavel = false
        break
      }else {
        var strFlag = Orion.GetLandTiledata(data.Graphic()).Flags().toString(16)
        if (strFlag[strFlag.length-2]+strFlag[strFlag.length-1] === "40"){
          tileAndavel = false
          break
        }
      }
    } 
    
  }else{
    return  ! containsObj // N tem tile eh pq nao existe nada
  }
  if (tileAndavel){
    var testaTileNegra = Orion.GetTiles('land', x, y)
    if (testaTileNegra && testaTileNegra.length > 0){
      if (Orion.GetTiles('land', x, y)[0].Flags().toString() == '80'){
        tileAndavel = false
      }
    }
  }
  //Orion.CharPrint(self, 906, 'eee '+pathOk+","+tileAndavel+","+containsObj);
  return tileAndavel && ! containsObj
}

function canWalk(x,y){
  //var lista = Orion.GetPathArrayEx(x,y,256,1,255,2,2)
  
}

function get_object_at(list,x,y){
  if (list){
    for (var i = 0; i < list.length; i++) {
      var obj = list[i];
      if (obj && obj.X() && obj.Y()){
        if (obj.X() == x && obj.Y() == y){
        return obj
      }
      }

    }
  }
  
}

function correr(){
  var print = false
  var target = Orion.FindObject('lasttarget');
  if (target){
    enemyList =  Orion.FindTypeEx("any", "-1", "ground", "ignorefriends|ignoreself", 30, "gray|red")//Orion.FindType("any", "-1", "ground", "near|mobile|ignorefriends", 18, "gray|red");
    var simInimigoX = target.X()
    var simInimigoY = target.Y()
    var inimigoList = [[simInimigoX,simInimigoY]]
    for(var i=0 ; i < enemyList.length; i++){
      var inim = enemyList[i];
      inimigoList.push(inim.X(),inim.Y())
    }
    var inimigoListPosition = []
    var vazio = "."
    var impassavel = "A"
    var inimigo = "E"
    var eu = "T"
    var onComplete = function (mapa, gradeX, gradeY){
      var playerPosition = undefined
      var loc = 'E:/git/UO Orion Macros/teste.txt'
      var file = print?Orion.NewFile(loc):undefined
      var create = print?file.Open(loc):true
      if (create){
        var mapeado = []
        for (var i = 0; i < gradeX; i++) {
          var mapeadoRow = []
          var row = "";
          for (var j = 0; j < gradeY; j++) {
            var strObj = vazio
            if (mapa[i][j][0] == Player.X() && mapa[i][j][1] == Player.Y()){
              strObj = eu
              playerPosition = {x:i,y:j}
            }else{
              var achouInimigo = false
              for(var inimIndex = 0; inimIndex < inimigoList.length; inimIndex++){
                var inimigoX = inimigoList[inimIndex][0]
                var inimigoY = inimigoList[inimIndex][1]
                if (mapa[i][j][0] == inimigoX && mapa[i][j][1] == inimigoY){
                  achouInimigo = true
                  strObj = inimigo
                  inimigoListPosition[inimigoListPosition.length] = {x:i,y:j}
                  break
                }
              }
              if (!achouInimigo){
                var andavel = isTileAndavel(mapa[i][j][0],mapa[i][j][1],Player.Z())
                if (!andavel){
                  strObj = impassavel
                }
              }
            }
            mapeadoRow[j] = strObj
            row += ''+strObj;
          }
          mapeado[i] = mapeadoRow
          if (print){
            file.Write(row+"\n");
          }
        }
        if (playerPosition){
          const safeSpot = findSafeSpot(mapeado, playerPosition.x, playerPosition.y)
          if (safeSpot){
            var xRun = mapa[safeSpot.x][safeSpot.y][0]
            var yRun = mapa[safeSpot.x][safeSpot.y][1]
            Orion.CharPrint(self, 906, "aa "+xRun+" - "+yRun+" - "+inimigoList.length);
            var callb = function(x,y){
              andarPara(x,y)
              //Orion.CharPrint(self, 906, "aaccc "+x+" - "+y);
            }
            //drawPath(mapeado, playerPosition.x, playerPosition.y, safeSpot.x, safeSpot.y, callb);
            callb(xRun,yRun)
          }
        }
        if (print){
          file.Close();
        }
      }

    }
    //row += '('+mapa[i][j][0]+','+mapa[i][j][1]+'-'+andavel+'),';
    scanTela(onComplete);
  }
}
function testexx(){
  //var objetos_chao = Orion.FindTypeEx('any', '-1', ground, 'ignoreself', '18');
  //var inimigos = Orion.FindType('any', '-1', ground, 'ignoreself', '18');
  //Orion.CanWalk("North", 4093,321,Player.Z())
  //var obj = get_object_at(objetos_chao,4093,321)
  //var obj2 = get_object_at(objetos_chao,4094,323)
  //Orion.GetLandTiledata(graph)
  //tileAt = Orion.GetTiles('any', 4091, 323, 0, 10);
  //Orion.WalkTo(4091, 323, 0, 0, 10, 2, 1);
  //Orion.CharPrint(self, 906, ""+data);
  //var data = Orion.GetLandTiledata(Orion.GetTiles('any', 4093, 322, 0, 3)[0].Graphic())
  //var fl = data.Flags()
  //Orion.CharPrint(self, 906, ""+fl);
  var onComplete = function (mapa, gradeX, gradeY){
    
    var loc = 'E:/git/UO Orion Macros/teste.txt'
    var file = Orion.NewFile(loc);
    var create = file.Open(loc)
    if (create){
      for (var i = 0; i < gradeX; i++) {
          var row = "";
          for (var j = 0; j < gradeY; j++) {
              //Orion.CanWalk("North", mapa[i][j][0]-1,mapa[i][j][1],Player.Z())
              var andavel = isTileAndavel(mapa[i][j][0],mapa[i][j][1],Player.Z())
              row += '('+mapa[i][j][0]+','+mapa[i][j][1]+'-'+andavel+'),';
          }
          file.WriteLine(row);
      }
      file.Close();
    }
  }
  scanTela(onComplete);

}

function scanTela(onComplete){
  //var tiles = Orion.GetTiles("any",Player.X,Player.Y);
  //if (tiles){
  //  Orion.CharPrint(self, 906, "aaaa"+Orion.GetGraphic(tiles));
  //}
  //Orion.CharPrint(self, 906, "CanWalk -"+Player.X()+","+Player.Y()+" - "+Orion.CanWalk("North", Player.X()-1,Player.Y()-1,Player.Z()));
  var StartX = gridSize/2
  var StartY = gridSize/2
  var gradeX = gridSize
  var gradeY = gridSize
  var run = create2DArray(gradeX, gradeY, 0);
  var count = 1
  var callback = function(x,y){
    var xPlayer = Player.X()
    var yPlayer = Player.Y()
    xPlayer = xPlayer+(x-StartX)
    yPlayer = yPlayer+(y-StartY)
    run[y][x] = [xPlayer,yPlayer] // Inverte o xy para se adequar ao jogo
    
    if (count>=gradeX*gradeY){
      onComplete(run, gradeX, gradeY)
    }

    count = count+1
  }
  
  percorrerAteLimite(gradeX,gradeY,StartX,StartY,gradeX,gradeY, callback)

}



function abs(value) {
  return value < 0 ? -value : value;
}

function distance(x1, y1, x2, y2) {
  return abs(x2 - x1) + abs(y2 - y1);
}

function hasLineOfSight(grid, x1, y1, x2, y2) {
  const dx = abs(x2 - x1);
  const dy = abs(y2 - y1);
  const sx = (x1 < x2) ? 1 : -1;
  const sy = (y1 < y2) ? 1 : -1;
  var err = dx - dy;

  while (true) {
    if (x1 === x2 && y1 === y2) return true;
    if (grid[y1][x1] === 'P' || grid[y1][x1] === 'A') return false;

    const e2 = err * 2;
    if (e2 > -dy) {
      err -= dy;
      x1 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y1 += sy;
    }

    if (x1 === x2 && y1 === y2) break;
  }
  return true;
}

function countObstaclesBetween(grid, x1, y1, x2, y2) {
  var dx = abs(x2 - x1);
  var dy = abs(y2 - y1);
  var sx = (x1 < x2) ? 1 : -1;
  var sy = (y1 < y2) ? 1 : -1;
  var err = dx - dy;
  var count = 0;

  while (!(x1 === x2 && y1 === y2)) {
    if (grid[y1][x1] === 'P') count++;

    var e2 = err * 2;
    if (e2 > -dy) {
      err -= dy;
      x1 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y1 += sy;
    }
  }

  return count;
}

function isAccessible(grid, startX, startY, endX, endY, visited) {
  if (visited[endY][endX]) return true;

  var queue = [{ x: startX, y: startY }];
  visited[startY][startX] = true;

  var directions = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 }
  ];

  while (queue.length > 0) {
    var current = queue.shift();
    var x = current.x;
    var y = current.y;
    if (x === endX && y === endY) return true;

    for (var i = 0; i < directions.length; i++) {
      var nx = x + directions[i].dx;
      var ny = y + directions[i].dy;

      if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length && !visited[ny][nx] && (grid[ny][nx] === '.' || grid[ny][nx] === 'T')) {
        visited[ny][nx] = true;
        queue.push({ x: nx, y: ny });
      }
    }
  }

  return false;
}

function findSafeSpot(grid, playerX, playerY) {
  var bestSpot = null;
  var maxDistance = -1;
  var maxObstacles = -1;

  for (var y = 0; y < grid.length; y++) {
    for (var x = 0; x < grid[0].length; x++) {
      if (grid[y][x] === '.' || grid[y][x] === 'P') {
        var safe = true;
        var totalObstacles = 0;
        for (var ey = 0; ey < grid.length; ey++) {
          for (var ex = 0; ex < grid[0].length; ex++) {
            if (grid[ey][ex] === 'E') {
              if (hasLineOfSight(grid, ex, ey, x, y)) {
                safe = false;
                break;
              }
              totalObstacles += countObstaclesBetween(grid, ex, ey, x, y);
            }
          }
          if (!safe) break;
        }
        if (safe) {
          var visited = Array.from({ length: grid.length }, () => Array(grid[0].length).fill(false));
          if (isAccessible(grid, playerX, playerY, x, y, visited)) {
            var dist = distance(playerX, playerY, x, y);
            if (dist > maxDistance || (dist === maxDistance && totalObstacles > maxObstacles)) {
              bestSpot = { x: x, y: y };
              maxDistance = dist;
              maxObstacles = totalObstacles;
            }
          }
        }
      }
    }
  }
  return bestSpot;
}

function findPath(grid, startX, startY, endX, endY) {
  var path = [];
  var x = startX, y = startY;
  var dx = abs(endX - startX);
  var dy = abs(endY - startY);
  var sx = (startX < endX) ? 1 : -1;
  var sy = (startY < endY) ? 1 : -1;
  var err = dx - dy;

  while (!(x === endX && y === endY)) {
    path.push({ x: x, y: y });
    var e2 = err * 2;
    if (e2 > -dy) {
      err -= dy;
      x += sx;
    }
    if (e2 < dx) {
      err += dx;
      y += sy;
    }
  }

  path.push({ x: endX, y: endY });
  return path;
}

function findPathToSafeSpot(grid, playerX, playerY) {
  var safeSpot = findSafeSpot(grid, playerX, playerY);
  if (safeSpot) {
    return findPath(grid, playerX, playerY, safeSpot.x, safeSpot.y);
  } else {
    return []; // Nenhum local seguro encontrado
  }
}
